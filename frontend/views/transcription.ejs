<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏</title>
    <link rel="stylesheet" href="/transcribe/public/styles/main.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Onest:wght@100..900&display=swap" rel="stylesheet">
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üéôÔ∏è –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏</h1>
            <p>–æ—Ç Artezon</p>
        </div>

        <div class="main_content">
            <a href="/transcribe" class="button button-secondary back-button">‚Üê –ù–∞–∑–∞–¥</a>

            <div class="status-card">
                <div class="status-item">
                    <span class="status-label">–ù–∞–∑–≤–∞–Ω–∏–µ</span>
                    <span class="status-value" id="fileName">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">–Ø–∑—ã–∫</span>
                    <span class="status-value" id="speechLanguage">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label" id="progressLabel">–ó–∞–≥—Ä—É–∑–∫–∞...</span>
                    <span class="status-value" id="progressValue">-</span>
                </div>
            </div>

            <div class="progress-bar" style="margin-bottom: 20px;">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div class="button-group" id="cancel-group" style="display: none;">
                <button type="button" class="button button-small cancel-button" id="cancelTranscriptionBtn">–û—Ç–º–µ–Ω–∞</button>
            </div>
            
            <div class="button-group" id="save-group" style="display: none;">
                <button type="button" class="button button-small" id="copyTextBtn">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç</button>
                <button type="button" class="button button-small" id="copyTextWithTimestampsBtn">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏</button>
                <button type="button" class="button button-small" id="saveTextBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç</button>
                <button type="button" class="button button-small" id="saveTextWithTimestampsBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏</button>
                <button type="button" class="button button-small" id="saveLrcBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ .lrc</button>
                <button type="button" class="button button-small" id="saveSubtitlesBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ —Å—É–±—Ç–∏—Ç—Ä—ã</button>
            </div>
            
            <div class="transcription-output" id="transcriptionOutput">
                <div id="transcription-output-box"></div>
                <div id="transcription-loading-container" style="margin-bottom: -10px; text-align: center; color: #64748b;">
                    <div class="loading"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class TranscriptionPage {
            constructor(taskId) {
                this.taskId = taskId;
                this.eventSource = null;
                this.languageMap = {
                    'af': '–ê—Ñ—Ä–∏–∫–∞–∞–Ω—Å',
                    'ar': '–ê—Ä–∞–±—Å–∫–∏–π',
                    'hy': '–ê—Ä–º—è–Ω—Å–∫–∏–π',
                    'az': '–ê–∑–µ—Ä–±–∞–π–¥–∂–∞–Ω—Å–∫–∏–π',
                    'be': '–ë–µ–ª–æ—Ä—É—Å—Å–∫–∏–π',
                    'bs': '–ë–æ—Å–Ω–∏–π—Å–∫–∏–π',
                    'bg': '–ë–æ–ª–≥–∞—Ä—Å–∫–∏–π',
                    'ca': '–ö–∞—Ç–∞–ª–∞–Ω—Å–∫–∏–π',
                    'zh': '–ö–∏—Ç–∞–π—Å–∫–∏–π',
                    'hr': '–•–æ—Ä–≤–∞—Ç—Å–∫–∏–π',
                    'cs': '–ß–µ—à—Å–∫–∏–π',
                    'da': '–î–∞—Ç—Å–∫–∏–π',
                    'nl': '–ù–∏–¥–µ—Ä–ª–∞–Ω–¥—Å–∫–∏–π',
                    'en': '–ê–Ω–≥–ª–∏–π—Å–∫–∏–π',
                    'et': '–≠—Å—Ç–æ–Ω—Å–∫–∏–π',
                    'fi': '–§–∏–Ω—Å–∫–∏–π',
                    'fr': '–§—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π',
                    'gl': '–ì–∞–ª–∏—Å–∏–π—Å–∫–∏–π',
                    'de': '–ù–µ–º–µ—Ü–∫–∏–π',
                    'el': '–ì—Ä–µ—á–µ—Å–∫–∏–π',
                    'he': '–ò–≤—Ä–∏—Ç',
                    'hi': '–•–∏–Ω–¥–∏',
                    'hu': '–í–µ–Ω–≥–µ—Ä—Å–∫–∏–π',
                    'is': '–ò—Å–ª–∞–Ω–¥—Å–∫–∏–π',
                    'id': '–ò–Ω–¥–æ–Ω–µ–∑–∏–π—Å–∫–∏–π',
                    'it': '–ò—Ç–∞–ª—å—è–Ω—Å–∫–∏–π',
                    'ja': '–Ø–ø–æ–Ω—Å–∫–∏–π',
                    'kn': '–ö–∞–Ω–Ω–∞–¥–∞',
                    'kk': '–ö–∞–∑–∞—Ö—Å–∫–∏–π',
                    'ko': '–ö–æ—Ä–µ–π—Å–∫–∏–π',
                    'lv': '–õ–∞—Ç—ã—à—Å–∫–∏–π',
                    'lt': '–õ–∏—Ç–æ–≤—Å–∫–∏–π',
                    'mk': '–ú–∞–∫–µ–¥–æ–Ω—Å–∫–∏–π',
                    'ms': '–ú–∞–ª–∞–π—Å–∫–∏–π',
                    'mr': '–ú–∞—Ä–∞—Ç—Ö–∏',
                    'mi': '–ú–∞–æ—Ä–∏',
                    'ne': '–ù–µ–ø–∞–ª—å—Å–∫–∏–π',
                    'no': '–ù–æ—Ä–≤–µ–∂—Å–∫–∏–π',
                    'fa': '–ü–µ—Ä—Å–∏–¥—Å–∫–∏–π',
                    'pl': '–ü–æ–ª—å—Å–∫–∏–π',
                    'pt': '–ü–æ—Ä—Ç—É–≥–∞–ª—å—Å–∫–∏–π',
                    'ro': '–†—É–º—ã–Ω—Å–∫–∏–π',
                    'ru': '–†—É—Å—Å–∫–∏–π',
                    'sr': '–°–µ—Ä–±—Å–∫–∏–π',
                    'sk': '–°–ª–æ–≤–∞—Ü–∫–∏–π',
                    'sl': '–°–ª–æ–≤–µ–Ω—Å–∫–∏–π',
                    'es': '–ò—Å–ø–∞–Ω—Å–∫–∏–π',
                    'sw': '–°—É–∞—Ö–∏–ª–∏',
                    'sv': '–®–≤–µ–¥—Å–∫–∏–π',
                    'tl': '–¢–∞–≥–∞–ª—å—Å–∫–∏–π',
                    'ta': '–¢–∞–º–∏–ª—å—Å–∫–∏–π',
                    'th': '–¢–∞–π—Å–∫–∏–π',
                    'tr': '–¢—É—Ä–µ—Ü–∫–∏–π',
                    'uk': '–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π',
                    'ur': '–£—Ä–¥—É',
                    'vi': '–í—å–µ—Ç–Ω–∞–º—Å–∫–∏–π',
                    'cy': '–í–∞–ª–ª–∏–π—Å–∫–∏–π'
                };
                this.initializeElements();
                this.attachEventListeners();
                this.startSSE();
            }

            initializeElements() {
                this.speechLanguage = document.getElementById('speechLanguage');
                this.fileName = document.getElementById('fileName');
                this.progressLabel = document.getElementById('progressLabel');
                this.progressValue = document.getElementById('progressValue');
                this.progressFill = document.getElementById('progressFill');
                this.transcriptionOutput = document.getElementById('transcriptionOutput');
                this.transcriptionOutputBox = document.getElementById('transcription-output-box');
                this.loadingContainer = document.getElementById('transcription-loading-container');

                this.cancelGroup =  document.getElementById('cancel-group');
                this.saveGroup = document.getElementById('save-group');
            }

            attachEventListeners() {
                document.getElementById('cancelTranscriptionBtn').addEventListener('click', this.cancelTranscription.bind(this));

                document.getElementById('copyTextBtn').addEventListener('click', () => this.copyText(false));
                document.getElementById('copyTextWithTimestampsBtn').addEventListener('click', () => this.copyText(true));
                document.getElementById('saveTextBtn').addEventListener('click', () => this.saveText(false));
                document.getElementById('saveTextWithTimestampsBtn').addEventListener('click', () => this.saveText(true));
                document.getElementById('saveLrcBtn').addEventListener('click', () => this.saveAsLRC());
                document.getElementById('saveSubtitlesBtn').addEventListener('click', () => this.saveAsSRT());
            }

            startSSE() {
                this.closeSSE(); // Close any existing connection

                this.data = { segments: [] };

                fetch(`<%- backendOrigin %>/api/data/${this.taskId}`).then(resp => {
                    if (resp.status == 404) {
                        window.location.replace("/transcribe/404")
                    }
                })
                
                this.eventSource = new EventSource(`<%- backendOrigin %>/api/stream/${this.taskId}`);

                this.eventSource.onmessage = (event) => {
                    try {
                        this.newData = JSON.parse(event.data);
                        let segments = this.data.segments;
                        if (Array.isArray(this.newData.segments)) {
                            segments = segments.concat(this.newData.segments);
                        }
                        this.data = { ...this.data, ...this.newData };
                        this.data.segments = segments;
                        this.updateTranscriptionStatus();
                    } catch (error) {
                        console.error('Error parsing SSE data:', error);
                    }
                };

                this.eventSource.onerror = (error) => {
                    console.error('SSE connection error:', error);
                    this.closeSSE();

                    // Try to reconnect after a delay if not finished
                    setTimeout(() => {
                        if (!this.isTranscriptionFinished()) {
                            this.startSSE();
                        }
                    }, 5000);
                };
            }

            closeSSE() {
                if (this.eventSource) {
                    this.eventSource.close();
                    this.eventSource = null;
                }
            }

            updateTranscriptionStatus() {
                // Update language and name
                if (this.data.language) {
                    const languageName = this.languageMap[this.data.language] || this.data.language.toUpperCase();
                    this.speechLanguage.textContent = languageName;
                }
                if (this.data.name) {
                    this.fileName.textContent = this.data.name;
                    document.title = `–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏ - ${this.data.name}`
                }

                // Update queue position or progress
                const progressPercent = Math.round(this.data.progress * 100);
                if (this.data.queue_pos !== undefined && this.data.queue_pos !== null && this.data.queue_pos > 0) {
                    this.progressLabel.textContent = '–ú–µ—Å—Ç–æ –≤ –æ—á–µ—Ä–µ–¥–∏';
                    this.progressValue.textContent = this.data.queue_pos;
                } else if (this.data.cancelled) {
                    this.progressLabel.textContent = '–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º';
                    this.progressLabel.style.color = '#f59e0b';
                } else if (this.data.language === undefined) {
                    this.progressLabel.textContent = '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞...';
                    this.progressValue.textContent = '';
                } else if (this.data.progress === 1) {
                    this.progressLabel.textContent = '–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!!';
                    this.progressValue.textContent = '–£—Ä–∞ :3';
                    this.progressFill.style.width = `${progressPercent}%`;
                } else {
                    this.progressLabel.textContent = '–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ...';
                    this.progressValue.textContent = `${progressPercent}%`;
                    this.progressFill.style.width = `${progressPercent}%`;
                }

                // Update segments
                if (this.data.segments && this.data.segments.length > 0) {
                    this.updateTranscriptionOutput();
                }

                // Handle completion
                if (this.data.finished || this.data.error || this.data.cancelled) {
                    this.cancelGroup.style.display = 'none';
                    this.saveGroup.style.display = 'inline-block';
                    this.closeSSE();

                    this.loadingContainer.innerHTML = '';

                    if (this.data.error) {
                        this.transcriptionOutput.innerHTML = `
                            <div style="text-align: center; color: #ef4444;">
                                <div style="font-size: 2rem; margin-bottom: 10px;">‚ùå</div>
                                <div><strong>–û—à–∏–±–∫–∞:</strong> ${this.data.error}</div>
                            </div>
                        `;
                    }
                } else {
                    this.cancelGroup.style.display = 'inline-block';
                    this.saveGroup.style.display = 'none';
                }
            }

            updateTranscriptionOutput() {
                this.newData.segments.forEach(segment => {
                    const segmentDiv = document.createElement('div');
                    segmentDiv.className = 'segment';
                    segmentDiv.setAttribute('data-start', segment.start);

                    const timestamp = `${this.formatTimestamp(segment.start)} - ${this.formatTimestamp(segment.end)}`;
                    segmentDiv.innerHTML = `
                        <div class="timestamp">${timestamp}</div>
                        <div class="segment-text">${segment.text}</div>
                    `;

                    this.transcriptionOutputBox.appendChild(segmentDiv);
                });
            }

            formatTimestamp(seconds, separateHours = true, decimalPlaces = 0) {
                const hours = Math.floor(seconds / 3600)
                const minutes = separateHours ? Math.floor(seconds / 60 % 60) : Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                let res = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                if (separateHours && hours > 0) {
                    res = `${hours}:${res}`;
                }
                if (decimalPlaces > 0) {
                    const fraction = (seconds % 1).toFixed(decimalPlaces).slice(2);
                    res += `.${fraction}`;
                }
                return res;
            }

            async cancelTranscription() {
                if (!this.taskId) return;

                try {
                    const response = await fetch(`<%- backendOrigin %>/api/cancel/${this.taskId}`, {
                        method: 'POST'
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    console.log('Cancellation result:', result);

                } catch (error) {
                    console.error('Error cancelling transcription:', error);
                    alert('Error cancelling transcription: ' + error.message);
                }
            }

            isTranscriptionFinished() {
                return this.cancelGroup.style.display === 'none';
            }

            getPlainText(withTimestamps) {
                if (!this.data || !this.data.segments) return "";

                return this.data.segments.map(seg => {
                    const text = seg.text.trim();

                    if (withTimestamps) {
                        const formatted = `[${this.formatTimestamp(seg.start)}]`;
                        return `${formatted} ${text}`;
                    }

                    return text;
                }).join(withTimestamps ? '\n' : ' ');
            }

            copyText(withTimestamps) {
                const content = this.getPlainText(withTimestamps);
                const textarea = document.createElement('textarea');
                textarea.value = content;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                } catch (err) {
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç');
                }
                document.body.removeChild(textarea);
            }

            saveText(withTimestamps) {
                const content = this.getPlainText(withTimestamps);
                let filename = "transcription";
                if (this.data.name && this.data.name.includes('.')) {
                    filename = this.data.name.substring(0, this.data.name.lastIndexOf('.'));
                }
                this.downloadFile(content, withTimestamps ? `${filename}_timestamps.txt` : `${filename}.txt`);
            }

            saveAsLRC() {
                if (!this.data || !this.data.segments) return;

                const lrc = this.data.segments.map(seg => {
                    const total = seg.start;
                    const minutes = Math.floor(total / 60);
                    const seconds = Math.floor(total % 60);
                    const hundredths = Math.floor((total % 1) * 100);
                    const timeTag = `[${minutes}:${seconds.toString().padStart(2, '0')}.${hundredths.toString().padStart(2, '0')}]`;
                    return `${timeTag}${seg.text.trim()}`;
                }).join('\n');

                let filename = "transcription";
                if (this.data.name && this.data.name.includes('.')) {
                    filename = this.data.name.substring(0, this.data.name.lastIndexOf('.'));
                }
                this.downloadFile(lrc, `${filename}.lrc`);
            }

            saveAsSRT() {
                if (!this.data || !this.data.segments) return;

                const format = seconds => {
                    const hrs = Math.floor(seconds / 3600);
                    const mins = Math.floor((seconds % 3600) / 60);
                    const secs = Math.floor(seconds % 60);
                    const ms = Math.floor((seconds % 1) * 1000); // full milliseconds
                    return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
                };

                const srt = this.data.segments.map((seg, i) => {
                    return `${i + 1}\n${format(seg.start)} --> ${format(seg.end)}\n${seg.text.trim()}\n`;
                }).join('\n');

                let filename = "transcription";
                if (this.data.name && this.data.name.includes('.')) {
                    filename = this.data.name.substring(0, this.data.name.lastIndexOf('.'));
                }
                this.downloadFile(srt, `${filename}.srt`);
            }

            downloadFile(content, filename) {
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
                URL.revokeObjectURL(link.href);
            }
        }

        // Initialize the transcription page when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new TranscriptionPage(window.location.href.substring(window.location.href.lastIndexOf("/") + 1));
        });
    </script>
</body>
</html>